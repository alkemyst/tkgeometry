#summary A description of the different configuration files in _tkgeometry_ and _tkmaterial_

= Configuration Files in _tkgeometry_ and _tkmaterial_ =

When using the command line to run _tkgeometry_ or _tkmaterial_, the configuration files describing the geometry, the module settings and the involved materials of a specific tracker model are key. They allow the user to customise and fine-tune the model until it fits a given set of requirements, or to compare and contrast different options when modelling tracker properties.

The granularity of these options goes from fairly coarse to fairly fine. It is possible to change the number of barrels or endcaps, or the number of layers and discs per barrel and endcap. The size of a barrel or endcap, or the distance between barrels and endcaps can be modified. The number of strips or segments on a module can be adjusted by layer, by disc or by ring, as can its type. Finally, the list and the amount of materials needs to be specified by module type, by service or support structure category and by classifying it as a local or as a travelling component.

All of these options are bundled in the configuration files. The geometry configuration file describes the large-scale structure of the tracker. The settings file looks at layout variations for differents types of modules. And the material file assigns a mixture of physical components - and therefore weight - to the various available volume categories.

_All configuration files are case sensitive._ They support both C-style and shell-style comments starting with '//' and '#', respectively. As expected, everything after the comment sign is ignored until the end of the line is reached.

----
----

= The Geometry Configuration File =

Geometry configuration files are structured as a series of blocks. Each of these starts with one of a list of keywords indicating its function and, in some cases, a name tag. The block contents are enclosed in curly braces. All numeric values are in _mm_ unless specified explicitly.

_As a rule, barrel, layer or disc indices start at 1._

==_Tracker_ Block==

The tracker block must be declared before all other components. It lists a number of global parameters and geometry settings of the overall tracker layout. There is exactly one such block in a geometry configuration file - no more, no less. Generally speaking, it looks something like this:

Tracker _trackername_ {
   zError = _value_;

   smallDelta = _value_;

   bigDelta = _value_;

   overlap = _value_;

   etaCut = _value_;

   ptCost = _value_;

   stripCost = _value_;

   ptPower = _value_;

   stripPower = _value_;
}

Whitespace is usually ignored, semicolons and curly braces are used as delimiters for parsing. 

===Parameters===

*_trackername_*: This is the name that will be given to the entire layout. It may also be used to name output (directories or files) in some cases.

*zError*: The range of z+ around the origin where a collision is most likely to occur. This value has an influence on how the modules in a layer or disc are laid out: specifically, with respect to overlap.

*smallDelta*: This describes the half the distance in Rho of two adjacent modules on the same rod. Namely, the _centre-to-centre_ distance of the two. Since this is a global default value for the entire tracker, it needs to be chosen in a way that prevents collisions between double-sided modules (which have another customisable distance between their two sensor surfaces). A re-declaration of this value in a _Barrel_ block for a specific layer will override the default for that layer. (Endcap solution pending...)

*bigDelta*: similar to _smallDelta_, this gives half the centre-to-centre distance of two rods in the same layer. The value in the _Tracker_ block is a global default that can be overridden by a re-declaration for a specific layer in one of the _Barrel_ blocks. (Endcap solution pending...)

*overlap*: The minimum overlap in z for two adjacent modules.

*etaCut*: The eta range that should be covered by the sensor surfaces. Modules created outside etaCut are discarded in the final layout.

*ptCost*: The estimated cost of a _sqare cm_ of pt module, in _CHF_.

*stripCost*: The estimated cost of a _sqare cm_ of rphi strip module, in _CHF_.

*ptPower*: The estimated power consumption _in mW_ for a single channel on a pt module.

*stripPower*: The estimaded power consumption _in mW_ for a single cannel on a rphi strip module.

----

==_Barrel_ Block==

A Barrel block bundles a number of parameters related to how the layer geometry should look. It says next to nothing definitive about the modules in them. Anything apart from their surface aspect ratio, their number along a rod and some options that help the layer building algorithms optimise their placement is left to the settings file. What the barrel block mainly does is define the dimensions of the barrel itself and give some information about positioning the layers within.

Barrel blocks may appear _after_ the tracker block _in any order_. There must be _at least one_, but there is _no upper limit_. The barrels that these blocks describe are built up in the order of the blocks as they appear in the configuration file. This order is completely up to the user - as is the responsibility to make sure they more or less fit together.

_tkgeometry_ supports various types of layers. The standard one goes across z=0 and extends to the same length into z+ and z-. Short layers that lie entirely to one side of z=0 are also possible, as well as declaring a layer _stacked_, i.e. duplicating it at a radius very close to that of the original to obtain a layer pair. All of these things can be combined to cover a range of layouts.

The application uses default values for any optional parameters that are not specified explicitly.

A _Barrel_ block more or less looks like this:

Barrel _barrelname_ {

   //mandatory

   nLayers = _value_;

   nModules = _value_;

   innerRadius = _value_;

   outerRadius = _value_;

   //optional (selection)

   aspectRatio = _value_;

   minimumZ = _value_;

   phiSegments = _value_;

   smallDelta{{{[}}}_layerindex_{{{]}}} = _value_;

   option{{{[}}}_layerindex_{{{]}}} = Stacked;
}

===Mandatory Parameters===

*_barrelname_*: The name of the barrel. Can be any alphanumeric string. Mostly to identify individual barrels to the user.

*nLayers*: The number of layers in the barrel. The first and last of them are built up around _innerRadius_ and _outerRadius_, respectively. The rest is distributed at equal intervals in between, taking into account constraints from directives and other options.

*nModules*: The number of modules in z+ on a single rod. In other words, half the number of modules across the full length of a layer.

*innerRadius*: The minimum radius of the barrel and the average radius of the first layer.

*outerRadius*: The maximum radius of the barrel and the average radius of the last layer.

===Optional Parameters===

*aspectRatio*: This defines the shape and size of a module since the diameter of a round wafer is always the same. The _default is 1.0_, i.e. square modules.

*minimumZ*: If this parameter is given as anything greater than zero, it means that the barrel layers are short and don't cross z=0. The given value then indicates the _starting point of a rod_. The number of modules given in mandatory parameter _nModules_ is then placed from there on outwards (in z). A mirror image of the layer is later built up in z-. If the parameter is omitted, the application assumes a standard layer crossing z=0 and places the first module on a rod around the origin, covering both z+ and z- outward from there.

*phiSegments*: The number of symmetric segments that make up a full circle for a layer cylinder. Note that this is a _barrel-wide_ division - the individual layers are split up according to the same rule so that the entire barrel comes apart in wedges of equal size. The _default is 4_.

*smallDelta*: If defined, this parameter overrides the global value from the _Tracker_ block for the layer given by _layerindex_.

*bigDelta*: Similar to _smallDelta_, this overrides the global value from the _Tracker_ block for the layer given by _layerindex_.

*size*: This defines the surface area of a module if the application should not simply use the entire wafer to create it. The combination of _aspectRatio_ and this parameter completely describes shape and size of a module in that case, while module size is implied by the size of the wafer in the standard one.

*option*: Currently, the only supported option is _Stacked_. This causes a layer to be duplicated at a short radial distance from the original, creating a layer pair. As an example, if the barrel has four layers and layer 3 is declared as stacked, the result will be layer 1 at _innerRadius_, layer 4 at _outerRadius_, layer 2 and _two copies_ of layer 3 in between: layer 2 at 1/3 of the radial range and the copies of layer 3 around 2/3 of the radial range.

*directive*: Directives are declared using a syntax of *_layerindex_/_constraint_* and give indications on where the radius of the specified layer should ideally be. The _constraint_ part of the directive can be either a _number_ or one of the letters *F*, *S*, *E*, or *A*. If it is a number, the specified layer is built at that radius, no questions asked. The letters have the following meaning:
  * *F*: Fixed. The radius of the layer is calculated from the number of layers and the radius range. It is not adjusted afterwards - even though an odd number of rods will cause a collision between the first and the last rod. (They'll end up on the same side with respect to the average layer radius.)
  * *S*: Shrink. If the number of rods that would fit into the calculated radius is an odd number, one rod is _removed_ and the radius adjusted to guarantee complete sensor coverage.
  * *E*: Enlarge. If the number of rods that would fit into the calculated radius is an odd number, one rod is _added_ and the radius adjusted to guarantee complete sensor coverage.
  * *A*: Auto. If the number of rods that would fit into the calculated radius is an uneven number, the results of removing a rod and adding one (i.e. of shrinking and enlarging the radius) are compared. The variant that is more conservative with respect to sensor covearge wins.

The default directive for all layers is *A*.

----

==_Endcap_ Block==

Like the _Barrel_ block, an _Endcap_ block bundles a number of parameters related to how the disc geometry should look while leaving most module specifics to the settings file. It defines the dimensions of the endcap itself and gives a few pointers towards how to distribute the modules within a disc.

Also like the _Barrel_ blocks, endcaps can be declared _in any order_ as long as the declaration appears after the _Tracker_ block. There is _no upper limit_ to the number of endcaps, but they're _not mandatory_ either: if none is defined, the application will simply produce a _barrel-only_ layout. Once again, their order in the configuration file and the responsibility to make them fit together is entirely up to the user.

What is declared in the _Endcap_ block is actually the z+ side of the endcap - the z- side is a mirror image of it. A disc is further subdivided into rings and then into modules. The number of rings is not given explicitly but computed internally from the size of the disc and the size of the modules. Unlike the barrel, endcap discs can consist of more than one type of module, and often do: if, say, ring 2 is defined as being of type _stereo_ (the rest of the rings being of type _rphi_, typically), then it is double-sided in _every_ disc of the endcap.

An index for a parameter first and foremost names _a ring, not a disc_ for just this reason. The indexed property then applies across all discs for that particular ring. Parameters given for ring indices that would place the ring outside the disc are ignored.

As above, the application uses default values for any optional parameters that are not specified explicitly.

An _Endcap_ block more or less looks like this:

Endcap _endcapname_ {

   //mandatory

   nDisks = _value_;

   innerRadius = _value_;
   _*or*_
   innerEta = _value_;

   outerRadius = _value_;

   minimumZ = _value_;
   _*or*_
   barrelGap = _value_;

   diskParity = _value_;

   //optional

   aspectRatio = _value_;

   phiSegments = _value_;

   shape = _wedge_ || _rectangular_;

   directive = _rule_;

}

===Mandatory Parameters===

*_endcapname_*: The name of the endcap pair. Can be any alphanumeric string. Mostly to identify individual endcap pairs to the user.

*nDisks*: The number of discs _in z+_. The total number of discs in both endcaps will be twice this number.

*innerRadius*: The minimum radius of the endcap and the smallest radius of the first ring. Mutually exclusive with _innerEta_.

*innerEta*: The eta of a hypothetical track that hits the lower left corner of the endcap. Mutually exclusive with _innerRadius_.

*outerRadius*: The maximum radius of the endcap and the greatest radius of the last ring.

*minimumZ*: The leftmost z of the z+ endcap. Mutually exclusive with _barrelGap_.

*barrelGap*: The distance between the right-hand end of the barrel and the left-hand end of the endcap. Mutually exclusive with _minimumZ_.

*diskParity*: This parameter indicates whether the first ring in each disc should be shifted towards z=0 or away from it. The value is either *1* or *-1*: the first of these moves the ring towards z=0, the other one moves it away.

===Optional Parameters===

*aspectRatio*: This defines the shape and size of a module in combination since the diameter of a round wafer is always the same. The _default is 1.0_, i.e. same height and width. Mutually exclusive with _shape = wedge_.

*phiSegments*: The number of symmetric segments that make up a full disc circle. Note that this is an _endcap-wide_ division - the individual rings are split up according to the same rule so that the entire endcap comes apart in wedges of equal size. The _default is 4_.

*shape*: Using one of the two keywords _wedge_ and _rectangular_, this is another fundamental parameter for the module shape. _shape = wedge_ is mutually exclusive with _aspectRatio_

*directive*: In a first approximation, the number of modules around a ring is calculated automatically. Directives change this unknown number by a given number of modules _for every segment in phi_. The number of modules can be either increased (+) or decreased (-). The sintax for a directive is of the form _ringNr_(+|-)_moduleChangePerSegment_ - so a rule of _5+2_ would mean that two modules are added to the calculated number in every segment of ring five.

*removeRings*: This parameter allows the user to remove some of the rings from selected discs after the overall endcap layout has been created. The rule syntax is of the form D _number_ R _number_ (+|-) - so a rule stating _D1R4+_ would remove remove the fourth ring and all those above it from disc one. (A rule of _D1R4-_ would remove the fourth ring and all those below.)

===Unimplemented===

*smallDelta{{{[}}}_ringindex_{{{]}}}*: Once implemented, this will have an effect similar to that of _smallDelta{{{[}}}_layerindex_{{{]}}}_ in the _Barrel_ blocks.

*bigDelta{{{[}}}_ringindex_{{{]}}}*: Once implemented, this will have an effect similar to that of _bigDelta{{{[}}}_layerindex_{{{]}}}_ in the _Barrel_ blocks.

----

==_Support_ Block==

Support structures and services around the modules are, for the most part, placed automatically - all of these are outside the overall layer and disc volumes. However, one of the application features allows users to define their own additional barrel supports within the length of the layers. The position of those needs to be declared in a _Support_ block.

The _Support_ block is optional: there is either _none or exactly one_.

An entry in the _Support_ block takes an optional barrel index defining the dimensions of the support in more detail. If _barrelindex_ is not specified, the structure reaches across all layers from above the first of the first barrel to below the last of the last barrel. If there is an index, the supports structure only extends across the given barrel. Barrels are numbered internally based on the radius of their layers, _not_ in the order that they are specified in the configuration file.

If a support is placed beyond the end of the barrels, it is ignored.

Support {

   midZ = _value_;
   midZ[_barrelindex_] = _value_;
             .
             .
             .
}

===Parameters===

*midZ*: This value indicates the position of a user-defined support structure in z+. A mirror image of the structure in z- will be created in addition unless the support is placed in z=0 - which is not recommended because the material budget estimate will be terrible.

----
----

= The Settings File =

==_BarrelType_ Block==

----

==_EndcapType Block_==

----
----

= The Material File =

--units

--L/E marker

----

==Modules==

===Types===
--type keyword

--nStripsAcross keyword

--nSegments keyword

===Materials===

--M marker (A, B, C, D division)

----

==Services==

--S marker (static)

--D marker (mapping)

----

==Supports==

--V/W/X/Y/Z markers (one each)
#summary A description of the different configuration files in _tkgeometry_ and _tkmaterial_

= Configuration Files in _tkgeometry_ and _tkmaterial_ =

When using the command line to run _tkgeometry_ or _tkmaterial_, the configuration files describing the geometry, the module settings and the involved materials of a specific tracker model are key. They allow the user to customise and fine-tune the model until it fits a given set of requirements, or to compare and contrast different options when modelling tracker properties.

The granularity of these options goes from fairly coarse to fairly fine. It is possible to change the number of barrels or endcaps, or the number of layers and discs per barrel and endcap. The size of a barrel or endcap, or the distance between barrels and endcaps can be modified. The number of strips or segments on a module can be adjusted by layer, by disc or by ring, as can its type. Finally, the list and the amount of materials needs to be specified by module type, by service or support structure category and by classifying it as a local or as a travelling component.

All of these options are bundled in the configuration files. The geometry configuration file describes the large-scale structure of the tracker. The settings file looks at layout variations for differents types of modules. And the material file assigns a mixture of physical components - and therefore weight - to the various available volume categories.

_All configuration files are case sensitive._ They support both C-style and shell-style comments starting with '//' and '#', respectively. As expected, everything after the comment sign is ignored until the end of the line is reached.

----

= The Geometry Configuration File =

Geometry configuration files are structured as a series of blocks. Each of these starts with one of a list of keywords indicating its function and, in some cases, a name tag. The block contents are enclosed in curly braces. All numeric values are in _mm_ unless specified explicitly.

_As a rule, layer or disc indices start at 1._

==_Tracker_ block==

The tracker block must be declared before all other components. It lists a number of global parameters and geometry settings of the overall tracker layout. There is exactly one such block in a geometry configuration file - no more, no less. Generally speaking, it looks something like this:

Tracker _trackername_ {
   zError = _value_;

   smallDelta = _value_;

   bigDelta = _value_;

   overlap = _value_;

   etaCut = _value_;

   ptCost = _value_;

   stripCost = _value_;

   ptPower = _value_;

   stripPower = _value_;
}

Whitespace is usually ignored, semicolons and curly braces are used as delimiters for parsing. The parameters describe the following properties:

*_trackername_*: This is the name that will be given to the entire layout. It may also be used to name output (directories or files) in some cases.

*zError*: The range of z+ around the origin where a collision is most likely to occur. This value has an influence on how the modules in a layer or disc are laid out: specifically, with respect to overlap.

*smallDelta*: This describes the half the distance in Rho of two adjacent modules on the same rod. Namely, the _centre-to-centre_ distance of the two. Since this is a global default value for the entire tracker, it needs to be chosen in a way that prevents collisions between double-sided modules (which have another customisable distance between their two sensor surfaces). A re-declaration of this value in a _Barrel_ block for a specific layer will override the default for that layer. (Endcap solution pending...)

*bigDelta*: similar to _smallDelta_, this gives half the centre-to-centre distance of two rods in the same layer. The value in the _Tracker_ block is a global default that can be overridden by a re-declaration for a specific layer in one of the _Barrel_ blocks. (Endcap solution pending...)

*overlap*: The minimum overlap in z for two adjacent modules.

*etaCut*: The eta range that should be covered by the sensor surfaces. Modules created outside etaCut are discarded in the final layout.

*ptCost*: The estimated cost of a _sqare cm_ of pt module, in _CHF_.

*stripCost*: The estimated cost of a _sqare cm_ of rphi strip module, in _CHF_.

*ptPower*: The estimated power consumption _in mW_ for a single channel on a pt module.

*stripPower*: The estimaded power consumption _in mW_ for a single cannel on a rphi strip module.

==_Barrel_ block==

A Barrel block bundles a number of parameters related to how the layer geometry should look. It says next to nothing definitive about the modules in them. Anything apart from their surface aspect ratio, their number along a rod and some options that help the layer building algorithms optimise their placement is left to the settings file. What the barrel block mainly does is define the dimensions of the barrel itself and give some information about positioning the layers within.

Barrel blocks may appear _after_ the tracker block _in any order_. There must be _at least one_, but there is _no upper limit_. The barrels that these blocks describe are built up in the order of the blocks as they appear in the configuration file. This order is completely up to the user - as is the responsibility to make sure they more or less fit together.

_tkgeometry_ supports various types of layers. The standard one goes across z=0 and extends to the same length into z+ and z-. Short layers that lie entirely to one side of z=0 are also possible, as well as declaring a layer _stacked_, i.e. duplicating it at a radius very close to that of the original to obtain a layer pair. All of these things can be combined to cover a range of layouts.

The application uses default values for any optional parameters that are not specified explicitly.

A barrel block looks more or less like this:

Barrel _barrelname_ {

   //mandatory

   nLayers = _value_;

   nModules = _value_;

   innerRadius = _value_;

   outerRadius = _value_;

   //optional

   aspectRatio = _value_;

   minimumZ = _value_;

   phiSegments = _value_;

   smallDelta{{{[}}}_layerindex_{{{]}}} = _value;

   option = Stacked;
}

The mandatory parameters have the following meaning:

*_barrelname_*: The name of the barrel. Can be any alphanumeric string. Mostly to identify individual barrels to the user.

*nLayers*: The number of layers in the barrel. The first and last of them are built up around _innerRadius_ and _outerRadius_, respectively. The rest is distributed at equal intervals in between, taking into account constraints from directives and other options.

*nModules*: The number of modules in z+ on a single rod. In other words, half the number of modules across the full length of a layer.

*innerRadius*: The minimum radius of the barrel and the average radius of the first layer.

*outerRadius*: The maximum radius of the barrel and the average radius of the last layer.

The optional parameters are explained below:

*aspectRatio*: This defines the shape and size of a module since the diameter of a round wafer is always the same. The _default is 1.0_, i.e. square modules.

*minimumZ*: If this parameter is given as anything greater than zero, it means that the barrel layers are short and don't cross z=0.

*phiSegments*: (barrel-wide division!)

*smallDelta*: 

*bigDelta*: 

*size*: 

*option*: 

*directive*: 

==_Endcap_ block==

==_Support_ block==

----

= The Settings File =

--BarrelType block

--EndcapType block

----

= The Material File =

--type keyword

--nStripsAcross keyword

--nSegments keyword

--L/E marker

--units

--M marker

--S marker

--D marker

--V/W/X/Y/Z markers (one each)